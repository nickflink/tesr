#include "tesr_rate_limiter.h"
#include <arpa/inet.h>
#include <pthread.h>
#include <regex.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // for strtoll
#include "tesr_common.h"
#include <utlist.h>
#include <uthash.h>

rate_limiter_t *create_rate_limiter() {
    rate_limiter_t *thiz = NULL;
    thiz = (rate_limiter_t*)malloc(sizeof(rate_limiter_t));
    TESR_LOG_ALLOC(thiz, rate_limiter_t);
    return thiz;
}

void init_rate_limiter(rate_limiter_t *rate_limiter, int ip_rate_limit_max, int ip_rate_limit_period, int ip_rate_limit_prune_mark) {
    rate_limiter->rate_limit_map = NULL;
    pthread_mutex_init(&rate_limiter->lock, NULL);
    rate_limiter->ip_rate_limit_max = ip_rate_limit_max;
    rate_limiter->ip_rate_limit_period = ip_rate_limit_period;
    rate_limiter->ip_rate_limit_prune_mark = ip_rate_limit_prune_mark;
}

void destroy_rate_limiter(rate_limiter_t *thiz) {
    if(thiz) {
        destroy_rate_limit_map(thiz->rate_limit_map);
        TESR_LOG_FREE(thiz, rate_limiter_t);
        free(thiz);
    } else {
        LOG_ERROR("can not free rate_limiter it is NULL");
    }
}

int prune_expired_ips(rate_limiter_t *rate_limiter) {
    int pruned = 0;
    LOG_DEBUG("LOCK prune_expired_ips thread = 0x%zx\n", (size_t)pthread_self());
    pthread_mutex_lock(&rate_limiter->lock);     //Don't forget locking
    LOG_DEBUG("LOCK AQUIRED prune_expired_ips thread = 0x%zx\n", (size_t)pthread_self());
    if(rate_limiter && HASH_COUNT(rate_limiter->rate_limit_map) >= rate_limiter->ip_rate_limit_prune_mark) {
        rate_limit_struct_t *rl = NULL;
        rate_limit_struct_t *tmp = NULL;
        time_t now;
        time(&now);
        double time_elapsed = 0.0;
        //UT_hash_handle hh; //generated by macro
        HASH_ITER(hh, rate_limiter->rate_limit_map, rl, tmp) {
            time_elapsed = difftime(now,rl->last_check);
            LOG_DEBUG("rl{%s} = %d [%f]sec elapsed\n", rl->ip, rl->count, time_elapsed);
            if(time_elapsed > rate_limiter->ip_rate_limit_period) {
                HASH_DEL(rate_limiter->rate_limit_map, rl);  // delete; rate_limit_map advances to next
                destroy_rate_limit(rl);
                ++pruned;
            }
        }
        LOG_DEBUG("prunning triggered %d object(s) pruned\n", pruned);
    }
    LOG_DEBUG("UNLOCK prune_expired_ips thread = 0x%zx\n", (size_t)pthread_self());
    pthread_mutex_unlock(&rate_limiter->lock);     //Don't forget locking
    LOG_DEBUG("UNLOCK RELEASED prune_expired_ips thread = 0x%zx\n", (size_t)pthread_self());
    return pruned;
}

int is_under_rate_limit(rate_limiter_t *rate_limiter, const char *ip) {
    int ret = 1;
    if(0 < rate_limiter->ip_rate_limit_max) {
      LOG_DEBUG("LOCK is_under_rate_limit thread = 0x%zx\n", (size_t)pthread_self());
        pthread_mutex_lock(&rate_limiter->lock);     //Don't forget locking
        LOG_DEBUG("LOCK AQUIRED is_under_rate_limit thread = 0x%zx\n", (size_t)pthread_self());
        //ADD RATE LIMIT
        rate_limit_struct_t *rl = NULL;
        HASH_FIND_STR( rate_limiter->rate_limit_map, ip, rl );
        if(!rl) {
            rl = create_rate_limit();
            init_rate_limit(rl, ip);
            HASH_ADD_STR( rate_limiter->rate_limit_map, ip, rl);
        }
        ++rl->count;
        if(rl->count > rate_limiter->ip_rate_limit_max) {
            LOG_INFO("[KO] rl->count=%d > %d=rate_limiter->ip_rate_limit_max\n", rl->count, rate_limiter->ip_rate_limit_max);
            ret = 0;
        } else {
            LOG_DEBUG("[OK] rl->count=%d <= %d=rate_limiter->ip_rate_limit_max\n", rl->count, rate_limiter->ip_rate_limit_max);
        }
        LOG_DEBUG("UNLOCK is_under_rate_limit thread = 0x%zx\n", (size_t)pthread_self());
        pthread_mutex_unlock(&rate_limiter->lock);     //Don't forget locking
        LOG_DEBUG("UNLOCK RELEASED is_under_rate_limit thread = 0x%zx\n", (size_t)pthread_self());
        //pthread_mutex_lock is not reentrant so we will unlock first
        //an easy improvement would be to pass whether we have the lock and only lock if we don't.  For complexities sake we will skip this for now
        prune_expired_ips(rate_limiter);
    }
    return ret;
}

